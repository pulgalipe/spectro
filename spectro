#!/usr/bin/env bash
trap 'exit' ERR
shopt -s nullglob
shopt -s extglob
shopt -s globstar

# Check for sox
command -v sox >/dev/null 2>&1 || { printf '%s\n' >&2 "This script requires SoX but it's not installed. Aborting."; exit 1; }

############################# BEGIN CONFIGURATION #############################

# Imgur API key. Read about it and register one here: https://api.imgur.com/oauth2
apikey=f6c67fcc0af0264

# Set offline=1 if you want to create local spectrals by default
# Can be reversed with the -l, --local flag
offline=0

# Set optipng=1 if you wish to use it by default
# Can be reversed with the -o, --optipng flag
optipng=1

# Set sha_check=1 if you wish to add SHA info to the output (uses shasum)
# Can be reversed with the -s, --sha flag
check_sha=0

# Set text_only=1 if you wish to display the spectrals as a link, with the filename as clickable source
# Can be reversed with the -t, --text flag
text_only=1

# Local directory where files will be stored (should be inside your public_html folder) when using -l, --local:
# Do NOT use a trailing slash
localdir="${HOME}"/www/"$(whoami)"."$(hostname -f)"/public_html/spectro

# URL format (example: http://yoursite.com/spectro/) for the -l, --local flag
# Do NOT use a trailing slash
urlformat=https://"$(hostname -f)"/"$(whoami)"/spectro

############################## END CONFIGURATION ##############################

show_help () {
  printf '%s\n'
  printf '%s\n' "Usage:"
  printf '%s\n' "    spectro <input1> <input2> ..."
  printf '%s\n' "Input can be individual files (MP3, WAV or FLAC) and/or a directories."
  printf '%s\n'
  printf '%s\n' "Options:"
  printf '%s\n' "    -d, --double    Take both zoomed in and full image for each file"
  printf '%s\n' "    -h, --help      Show this help and exit"
  printf '%s\n' "    -l, --local     Reverse the setting to output the spectrograms locally"
  printf '%s\n' "    -o, --optipng   Reverse the optipng option set in the script"
  printf '%s\n' "    -p, --parallel  Play nicely with parallel (example below)"
  printf '%s\n' "    -s, --sha       Reverse the check_sha option (to show SHA value)"
  printf '%s\n' "    -t, --text      Reverse the setting to use [url] tags or [img]"
  printf '%s\n' "    -z, --zoom      Create only zoomed in screenshot (3 seconds)"
  printf '%s\n'
  printf '%s\n' "Example: spectro -ol DirectoryWithMusic/"
  printf '%s\n'
  printf '%s\n' "Modify the first lines on the script to modify change the settings"
  printf '%s\n'
  printf '%s\n' "To process a directory with GNU parallel, first cd into it and then run:"
  printf '%s\n' "printf \"[hide=Spectrograms][size=3]\" && ls | parallel -k spectro -p; printf '%s\n' \"[/size][/hide]\""
  printf '%s\n'
}

sox_arguments=("-n remix 1 spectrogram -x 3000 -y 513 -z 120 -w Kaiser")

# Check arguments/options
while :; do
  case $1 in
    -d|--double)
      sox_arguments+=( "-n remix 1 spectrogram -x 500 -y 1025 -z 120 -w Kaiser -S 0:25 -d 0:04" )
      ;;
    -h|-\?|--help)   # Call a "show_help" function to display a synopsis, then exit.
      show_help
      exit
      ;;
    -l|--local)
      offline=$((!offline))
      ;;
    -o|--optipng)
      optipng=$((!optipng))
      ;;
    -p|--parallel)
      parallel=1
      ;;
    -s|--sha)
      check_sha=$((!check_sha))
      ;;
    -t|--text)
      text_only=$((!text_only))
      ;;
    -z|--zoom)
      zoom=1
      sox_arguments=("-n remix 1 spectrogram -x 500 -y 1025 -z 120 -w Kaiser -S 0:25 -d 0:04")
      ;;
    -?*)
      # Handle grouped options (eg. spectro -lot file)
      if [[ "${#1}" -ge "3" && ${1:1:1} != "-" ]]; then
        for (( i=1; i<${#1}; i++ )); do
          if [[ "${1:$i:1}" == "d" ]]; then
            sox_arguments+=( "-n remix 1 spectrogram -x 500 -y 1025 -z 120 -w Kaiser -S 0:25 -d 0:04" )
            continue
          fi
          if [[ "${1:$i:1}" == "l" ]]; then
            offline=$((!offline))
            continue
          fi
          if [[ "${1:$i:1}" == "o" ]]; then
            optipng=$((!optipng))
            continue
          fi
          if [[ "${1:$i:1}" == "p" ]]; then
            parallel=1
            continue
          fi
          if [[ "${1:$i:1}" == "s" ]]; then
            check_sha=$((!check_sha))
            continue
          fi
          if [[ "${1:$i:1}" == "t" ]]; then
            text_only=$((!text_only))
            continue
          fi
          if [[ "${1:$i:1}" == "z" ]]; then
            sox_arguments=("-n remix 1 spectrogram -x 500 -y 1025 -z 120 -w Kaiser -S 0:25 -d 0:04")
            zoom=1
            continue
          fi
          ignored_options="$ignored_options""${1:$i:1}"
          continue
        done
        if [[ -n "$ignored_options" ]]; then
          printf 'WARNING: Unknown options (ignored): %s\n' "$ignored_options" >&2
        fi
      else
        printf 'WARNING: Unknown option (ignored): %s\n' "$1" >&2
      fi
      shift 1
      continue
      ;;
    --)              # End of all options.
      shift
      break
      ;;
    *)               # Default case: If no more options then break out of the loop.
      break
  esac
  shift
done

# This will center the text for the title in spectrals if using the [img]spectral[/img] method
if ! [[ "$text_only" == "1" ]]; then
  align_in="[align=center]"
  align_out="[/align]"
fi

# If SHA is enabled, check that shasum is on the system, if not, disable it
if [[ "$check_sha" == "1" ]]; then
  command -v shasum >/dev/null 2>&1 || check_sha=0
fi

# If optipng is enabled, check that it is on the system, if not, disable it
if [[ "$optipng" == "1" ]]; then
  command -v optipng >/dev/null 2>&1 || optipng=0
fi

# Only check for curl dependency when not running in offline/local mode
if ! [[ "$offline" == "1" ]]; then
  command -v curl >/dev/null 2>&1 || { printf '%s\n' >&2 "This script requires curl but it's not installed. Aborting."; exit 1; }
fi

if [[ "$offline" == "1" ]]; then
  mkdir -p "$localdir"
fi

# Check there's at least one argument
if [ "$#" -lt 1 ]; then
  show_help
  exit 1
fi

create_spectrogram () {
  # If it's the second time we run sox or -z was used, we want the zoomed version
  if [[ "$sox_counter" == "2" || "$zoom" == 1 ]]; then
    if [[ "$offline" == "1" ]]; then
      # We will append this to the spectrogram filename
      zoom_filename='_zoom'
    fi
    zoom_url_text=' (Zoomed)'
  else
    # Set empty variables for multiple runs
    zoom_filename=''
    zoom_url_text=''
  fi
  if [[ "$offline" == "1" ]]; then
    # Spectrogram name: Replace invalid characters for underscore, add "zoom" and append "spectro.png"
    output_name="$(printf '%s\n' "$file_basename" | tr ";, " "_")_spectro${zoom_filename}.png"
    output_name="$localdir"/"$output_name"
    url="$urlformat"/"${output_name##*/}"
  else
    # Use temporary file as output, to avoid changing the last modified date on the directory and allow parallel runs on the same directory
    output_name="$(mktemp)"
  fi
  # Set title (directory name + filename)
  directory="$(dirname "$file")"
  directory="${directory##*/}"
  title="$directory/$file_basename"
  # Add SHA info if not using zoom (won't fit) and enabled
  if [[ "$check_sha" == "1" && -z "$zoom_url_text" ]]; then
    title="$title (SHA $file_sha)"
  fi
  # Create the spectrogram
  sox "$file" $sox_arg -t "$title" -o "$output_name" || return
  if [[ "$optipng" == "1" ]]; then optipng -quiet "$output_name"; fi
  # Upload to imgur and grab the URL if it's not in local mode
  if ! [[ "$offline" == "1" ]]; then
    printf "\rUploading $file_basename$zoom_url_text to imgur..."
    # Upload to imgur and replace http for https in the output
    response="$(curl -H "Authorization: CLIENT-ID $apikey" -F "image=@$output_name" \
      https://api.imgur.com/3/image.xml 2>/dev/null | tail -n +2 | sed 's/http:/https:/g' )"
    sleep 3
    curl_attempt=2
    # Check for errors so we can retry
    while [[ "$curl_attempt" -le 3 && "$response" == *"error"* ]]; do
      printf "\rSomething went wrong, trying again. Attempt $curl_attempt out of 3"
      ((curl_attempt++))
      sleep 2
      response="$(curl -H "Authorization: CLIENT-ID $apikey" -F "image=@$output_name" \
        https://api.imgur.com/3/image.xml 2>/dev/null | tail -n +2 | sed 's/http:/https:/g' )"
    done
    if [[ "$response" == *"error"* ]]; then
      # Parse the actual error to display it
      curl_error="$(printf '%s\n' "$response" | sed -E 's/.*<error>(.*)<\/error>.*/\1/')"
      printf "\rCouldn't upload this this image, reason: \"$curl_error\""
      rm "$output_name"
      return
    fi
    # Get the text between <link> </link> in the xml output
    url="$(printf '%s\n' "$response" | sed -E 's/.*<link>(.*)<\/link>.*/\1/')"
    # Delete spectrogram image
    rm "$output_name"
  fi
  if [[ "$text_only" == "1" ]]; then
    # tput to clear until end of line
    clear_line="$(tput el)"
    printf "\r$clear_line[url=$url]$file_basename$zoom_url_text[/url]\n"
  else
    printf "\r$clear_line[img]$url[/img]\n"
  fi
}

main (){
  content="$(file --mime-type "$file")"
  content="${content##* }"
  # Ignore files that aren't mp3, flac or wav
  if [[ "${content##* }" == *@(flac|mpeg|wav)* ]]; then
    # Print the first BBCode line and set a variable to avoid repeating it
    if [[ ! "$parallel" == "1" && ! "$valid_input" == "1" ]]; then printf "[hide=Spectrograms]$align_in[size=3]"; fi
    valid_input=1
  else
    return
  fi
  # New line before each file
  printf '%s\n'
  # Store basename for later use
  file_basename="$(basename "$file")"
  # Print name
  if ! [[ "$text_only" == "1" ]]; then printf '%s\n' "$file_basename"; fi
  # Only check hash if set as option. Store it for later use (as sox title & plaintext)
  if [[ "$check_sha" == "1" ]]; then file_sha="$(shasum "$file" | cut -d " " -f 1)"; fi
  # Show hash below name if using images (not text only)
  if [[ "$check_sha" == "1" && ! "$text_only" == "1" ]]; then printf '%s\n' "[size=1]SHA: $file_sha[/size]"; fi
  sox_counter=0
  for sox_arg in "${sox_arguments[@]}"; do
    ((sox_counter++))
    create_spectrogram || return
  done
  # Show hash below the URL, for text only/url mode
  if [[ "$text_only" == "1" && "$check_sha" == "1" ]]; then printf '%s\n' "[size=1]SHA: $file_sha[/size]"; fi
}

for file in "$@"; do
  if [[ -d "$file" ]]; then
    # Argument is a directory, cd into it and process all the files inside
    cd "$file"
    for file in **/*; do
      main || continue
    done
  fi
  # If it's not a directory, process the files by themselves
  if [[ -f "$file" ]]; then
    main || continue
  fi
done

if [[ ! "$valid_input" == "1" && ! "$parallel" = "1" ]]; then
  printf '%s\n' 'Invalid input, no allowed files found (MP3, FLAC or WAV).'
  exit 1
fi

 if [[ ! "$parallel" = "1" ]]; then printf '%s\n' "[/size]$align_out[/hide]"; fi
